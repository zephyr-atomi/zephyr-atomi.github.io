import{_ as i,c as a,a1 as s,o}from"./chunks/framework.C9fvGCe2.js";const t="/blog/002-driving-bldc-motors-with-six-step-commutation/six_step_commutation_bldc.mp4",n="/blog/002-driving-bldc-motors-with-six-step-commutation/quadrature-encoders-direction-determition.jpg",r="/blog/002-driving-bldc-motors-with-six-step-commutation/matched-pwm.png",l="/blog/002-driving-bldc-motors-with-six-step-commutation/six-pwm.png",b=JSON.parse('{"title":"Driving BLDC Motors with Six-Step Commutation","description":"This post demonstrates how to implement Six-Step Commutation to drive a BLDC motor using an STM32F405RGT6 development board, bypassing the typical configuration-heavy process associated with ODrive. The project explores TLE5012 encoder signal processing, PWM-based motor control, and STM32 timer functionality. A practical experimental setup is presented, showcasing the fundamentals of BLDC commutation, algorithm design, and STM32 capabilities.","frontmatter":{"type":"article","title":"Driving BLDC Motors with Six-Step Commutation","image":"/blog/002-driving-bldc-motors-with-six-step-commutation/featured.webp","description":"This post demonstrates how to implement Six-Step Commutation to drive a BLDC motor using an STM32F405RGT6 development board, bypassing the typical configuration-heavy process associated with ODrive. The project explores TLE5012 encoder signal processing, PWM-based motor control, and STM32 timer functionality. A practical experimental setup is presented, showcasing the fundamentals of BLDC commutation, algorithm design, and STM32 capabilities.","publishedOn":"22 Nov 2022 20:25","updatedOn":"22 Nov 2022 20:25","head":[["meta",{"property":"og:title","content":"Driving BLDC Motors with Six-Step Commutation"}],["meta",{"property":"og:description","content":"This post demonstrates how to implement Six-Step Commutation to drive a BLDC motor using an STM32F405RGT6 development board, bypassing the typical configuration-heavy process associated with ODrive."}],["meta",{"property":"keywords","content":"BLDC motors, Six-Step Commutation, STM32, TLE5012 encoder, PWM control, motor control algorithms"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:url","content":"https://zephyr-atomi.github.io/blog/002-driving-bldc-motors-with-six-step-commutation.html"}],["meta",{"property":"og:image","content":"https://zephyr-atomi.github.io/blog/002-driving-bldc-motors-with-six-step-commutation/featured.png"}],["meta",{"name":"twitter:title","content":"Driving BLDC Motors with Six-Step Commutation"}],["meta",{"name":"twitter:description","content":"Learn how to drive BLDC motors using Six-Step Commutation with STM32 and TLE5012 encoders."}],["meta",{"property":"og:url","content":"https://zephyr-atomi.github.io/blog/002-driving-bldc-motors-with-six-step-commutation.html"}],["meta",{"name":"twitter:image","content":"https://zephyr-atomi.github.io/blog/002-driving-bldc-motors-with-six-step-commutation/featured.png"}]]},"headers":[],"relativePath":"blog/002-driving-bldc-motors-with-six-step-commutation.md","filePath":"blog/002-driving-bldc-motors-with-six-step-commutation.md"}'),h={name:"blog/002-driving-bldc-motors-with-six-step-commutation.md"};function p(d,e,c,m,u,g){return o(),a("div",null,e[0]||(e[0]=[s('<p>I have an ODrive on hand, but going through the documentation and the process of running it with various BLDC motors has been quite tedious. After all this configuration, I feel confident enough to write my own code to drive it. Conveniently, I also have several STM32 test boards at hand. I grabbed an STM32F405RGT6 development board and successfully got the motor running on the ODrive using the Six-Step Commutation method.</p><p>Here’s a breakdown of the entire process and some key points.</p><h2 id="materials" tabindex="-1">Materials <a class="header-anchor" href="#materials" aria-label="Permalink to &quot;Materials&quot;">​</a></h2><ul><li><a href="https://www.aliexpress.us/item/3256807348504846.html" target="_blank" rel="noreferrer">Makerbase Odrive 3.6 56V Board</a></li><li><a href="https://www.aliexpress.us/item/3256805369870943.html" target="_blank" rel="noreferrer">X2212 Motor + TLE5012 Encoder</a></li><li>STLink v2</li><li>DC Power Supply</li></ul><h3 id="result-video" tabindex="-1">Result Video <a class="header-anchor" href="#result-video" aria-label="Permalink to &quot;Result Video&quot;">​</a></h3><video controls width="640"><source src="'+t+'" type="video/mp4"> Your browser does not support the video tag. </video><h2 id="tle5012-encoder-a-b-z-signal-processing" tabindex="-1">TLE5012 Encoder A/B/Z Signal Processing <a class="header-anchor" href="#tle5012-encoder-a-b-z-signal-processing" aria-label="Permalink to &quot;TLE5012 Encoder A/B/Z Signal Processing&quot;">​</a></h2><p>The TLE5012 is a magnetic encoder capable of outputting standard A/B/Z signals. To achieve precise commutation for the motor, we need to decode its position and direction using the A/B/Z signals.</p><h3 id="a-b-quadrature-signal-processing" tabindex="-1">A/B Quadrature Signal Processing <a class="header-anchor" href="#a-b-quadrature-signal-processing" aria-label="Permalink to &quot;A/B Quadrature Signal Processing&quot;">​</a></h3><p>The TLE5012 provides quadrature encoding output through its A/B pins.</p><p><img src="'+n+`" alt="Quadrature Encoder Diagram"><a href="https://eltra-encoder.eu/news/quadrature-encoder" target="_blank" rel="noreferrer"><em>Quadrature Encoder Diagram</em></a></p><p>By analyzing the state transitions of the A/B quadrature encoding (00/01/10/11), we can perform incremental counting, which also allows us to determine the motor&#39;s rotational direction. Using the STM32 Timer, we can easily obtain this information.</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Connect a rotary encoder to pins A0 and A1.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rotary_encoder_pins </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        gpiob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pb4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">into_floating_input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), gpiob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pb5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">into_floating_input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rotary_encoder_timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TIM3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rotary_encoder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Qei</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rotary_encoder_timer, rotary_encoder_pins);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rotary_encoder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> new_count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rotary_encoder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    info!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;curr: {}, new: {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, current_count, new_count);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="encoder-z-signal-processing" tabindex="-1">Encoder Z Signal Processing <a class="header-anchor" href="#encoder-z-signal-processing" aria-label="Permalink to &quot;Encoder Z Signal Processing&quot;">​</a></h3><p>The Z signal is a periodic pulse that generates a rising and falling edge once per rotation:</p><ul><li>The rising edge is used to mark the motor&#39;s &quot;zero point,&quot; enabling multi-turn position resetting.</li><li>For BLDC commutation, the Z signal trigger can be used to calibrate the phase.</li></ul><p>We can capture Z signal changes through interrupt triggers. Here’s an example of [the interrupt trigger code](<a href="https://github.com/zephyr-atomi/stm32f4-exp/blob/master/examples/qei.rs#L33" target="_blank" rel="noreferrer">https://github.com/zephyr-atomi/stm32f4-exp/blob/master/examples/qei.rs#L33</a>. This code is somewhat verbose, so we won’t include it here in detail. In simple terms, the Z signal’s Rising/Falling edges are captured by interrupts, allowing us to perform further processing. However, this code is just a demo and doesn’t perform any actual operations.</p><h2 id="six-step-commutation" tabindex="-1">Six-Step Commutation <a class="header-anchor" href="#six-step-commutation" aria-label="Permalink to &quot;Six-Step Commutation&quot;">​</a></h2><h3 id="mosfet-for-motor-driven" tabindex="-1">MOSFET For Motor Driven <a class="header-anchor" href="#mosfet-for-motor-driven" aria-label="Permalink to &quot;MOSFET For Motor Driven&quot;">​</a></h3><p>The ODrive circuitry is essentially similar to the H-bridge driver used in DC motors. Each end of a motor coil is controlled by two MOSFET switches, referred to as the H and L ends. A key principle here is that the H and L ends of the same coil must not be switched on simultaneously, as this would create a short circuit and should damage the hardware. This is a crucial consideration when writing code. With this setup, there are 6 MOSFETs to control the power flow. Additionally, by adjusting the PWM duty cycle, we can control the magnetic field generated in a given direction. Thus, 6 PWM inputs are required to control the circuit.</p><h3 id="understanding-how-the-rotor-is-driven" tabindex="-1">Understanding How the Rotor is Driven <a class="header-anchor" href="#understanding-how-the-rotor-is-driven" aria-label="Permalink to &quot;Understanding How the Rotor is Driven&quot;">​</a></h3><p>Let’s break it down: when two different coil H/L ends are energized, such as AH/BL, the direction of current flow through the coils generates forces. These forces combine into a resultant force. There are a total of 9 possible combinations of AH/BH/CH ~ AL/BL/CL, excluding the 3 combinations (e.g., AH~AL) that would result in a short circuit. This leaves six valid combinations. When equal forces are applied, the resultant force theoretically points to one of six directions around the circle, spaced at 60° intervals.</p><p>Six-step commutation simply alternates these six magnetic pole directions with equal force, generating a torque that drives the rotor.</p><h3 id="beyond-six-step-commutation" tabindex="-1">Beyond Six-Step Commutation <a class="header-anchor" href="#beyond-six-step-commutation" aria-label="Permalink to &quot;Beyond Six-Step Commutation&quot;">​</a></h3><p>More precise methods involve determining the rotor’s current position and creating a magnetic pole direction exactly opposite to the rotor’s current magnetic pole. This can be done using two or even three coil ends. This method maximizes torque based on the rotor’s inertia. Furthermore, by adjusting the PWM duty cycle at each terminal, the magnetic force magnitude can be controlled, allowing for optimal torque output. Such fine control is typically achieved using PID algorithms.</p><h3 id="video-reference" tabindex="-1">Video Reference <a class="header-anchor" href="#video-reference" aria-label="Permalink to &quot;Video Reference&quot;">​</a></h3><p>I haven’t come across particularly good YouTube videos explaining this process, but <a href="https://www.bilibili.com/video/BV1XvtNeaE54" target="_blank" rel="noreferrer">this Chinese video</a> might be helpful.</p><h3 id="challenges-and-observations" tabindex="-1">Challenges and Observations <a class="header-anchor" href="#challenges-and-observations" aria-label="Permalink to &quot;Challenges and Observations&quot;">​</a></h3><p>One key issue is the inevitable manufacturing imperfections in the motor, such as slight discrepancies in coil winding. These small errors can influence the direction and magnitude of the force generated, creating complications in motion control. I need to investigate this further to understand how to best synchronize the motor and driver. Based on these findings, we can determine how to compensate for hardware inaccuracies through software adjustments. This will clarify the level of hardware precision loss and the software solutions needed to address it.</p><h2 id="algorithm-requirements-and-implementation-on-stm32" tabindex="-1">Algorithm Requirements and Implementation on STM32 <a class="header-anchor" href="#algorithm-requirements-and-implementation-on-stm32" aria-label="Permalink to &quot;Algorithm Requirements and Implementation on STM32&quot;">​</a></h2><p>To implement six-step commutation or other advanced motor control algorithms, several key algorithmic components are needed. STM32 microcontrollers provide robust support for these tasks, making them ideal for motor control applications.</p><h3 id="algorithm-approach" tabindex="-1">Algorithm Approach <a class="header-anchor" href="#algorithm-approach" aria-label="Permalink to &quot;Algorithm Approach&quot;">​</a></h3><p>In this experiment, we will temporarily avoid using the encoder output discussed earlier to determine the rotor position for closed-loop control. Instead, based on the above discussion, we will implement six-step commutation. Specifically, we will cycle through the following sequence: <code>AH/BL =&gt; AH/CL =&gt; BH/CL =&gt; BH/AL =&gt; CH/AL =&gt; CH/BL</code>. For each step, we will introduce sufficient delay to ensure the rotor aligns with the magnetic field&#39;s defined direction before moving to the next step. Of course, this method will result in a clicking noise, but it is adequate for experimental verification of the concept. The algorithm can be summarized as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- After initialization, enter a loop.</span></span>
<span class="line"><span>- Identify the current step, turn off the PWM signals from the previous step, and activate the PWM signals corresponding to the current H/L step.</span></span>
<span class="line"><span>- Wait for sufficient time to allow the rotor to align with the desired position.</span></span></code></pre></div><p>Now, let’s move into the implementation.</p><h3 id="implementation-on-stm32" tabindex="-1">Implementation on STM32 <a class="header-anchor" href="#implementation-on-stm32" aria-label="Permalink to &quot;Implementation on STM32&quot;">​</a></h3><p>To meet the requirements above, we need STM32 support for generating a sufficient number of identical PWM signals. Based on our discussion, we need 6 PWM signals. Referring to the <a href="https://github.com/odriverobotics/ODriveHardware/blob/master/v3/v3.5docs/schematic_v3.5.pdf" target="_blank" rel="noreferrer">ODrive schematic</a>, the corresponding relationships are as follows:</p><ul><li>AH/BH/CH: PA8/PA9/PA10</li><li>AL/BL/CL: PB13/PB14/PB15</li></ul><h4 id="exploring-stm32-timers" tabindex="-1">Exploring STM32 Timers <a class="header-anchor" href="#exploring-stm32-timers" aria-label="Permalink to &quot;Exploring STM32 Timers&quot;">​</a></h4><p>Due to my initial lack of familiarity with STM32 timers, it took me a long time to figure this out. Eventually, I found the following code in the ODrive project and inferred that each STM32 timer can provide up to 8 identical PWM outputs:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sConfigOC.OCPolarity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TIM_OCPOLARITY_HIGH;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sConfigOC.OCNPolarity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TIM_OCNPOLARITY_HIGH;</span></span></code></pre></div><p>For example, if we connect AH/AL to two complementary outputs of the same PWM channel, their behavior will be identical because the timer (counter) determines when to output a high level. By setting the complementary output to also be high when the counter is exceeded, AH/AL will produce identical signals.</p><p>STM32 timers are extremely powerful, and exploring their full functionality is beyond the scope of this discussion. However, understanding this principle simplifies the implementation. You can refer to my <a href="https://github.com/zephyr-atomi/stm32f4-exp/blob/master/examples/motor-exp.rs#L63" target="_blank" rel="noreferrer">motor-exp</a> code for the detailed implementation.</p><h4 id="pwm-signal-verification" tabindex="-1">PWM Signal Verification <a class="header-anchor" href="#pwm-signal-verification" aria-label="Permalink to &quot;PWM Signal Verification&quot;">​</a></h4><p>After connecting the outputs of this code to my logic analyzer, I obtained the following results: <img src="`+r+'" alt="Two PWM details"><em>Two PWM Signals Details</em><img src="'+l+'" alt="Six PWM"><em>Six PWM Signals</em></p><h4 id="running-the-motor" tabindex="-1">Running the Motor <a class="header-anchor" href="#running-the-motor" aria-label="Permalink to &quot;Running the Motor&quot;">​</a></h4><p>After confirming the correctness of the PWM outputs, I flashed the code onto the STM32 chip on the ODrive. After powering it on and rebooting, I successfully observed the X2212 motor running smoothly. Below is the demo video again.</p><video controls width="640"><source src="'+t+'" type="video/mp4"> Your browser does not support the video tag. </video><p><em>Six-Steps Commutation Demo</em></p><h2 id="questions" tabindex="-1">Questions <a class="header-anchor" href="#questions" aria-label="Permalink to &quot;Questions&quot;">​</a></h2><p>Actually, there are still many questions regarding driving a motor, especially FOC and more. For now, I won’t elaborate on them here. I’ll take my time to figure them out step by step in the future.</p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p>This post demonstrates how to implement Six-Step Commutation to drive a BLDC motor using an STM32F405RGT6 development board, bypassing the typical configuration-heavy process associated with ODrive. The project explores TLE5012 encoder signal processing, PWM-based motor control, and STM32 timer functionality. A practical experimental setup is presented, showcasing the fundamentals of BLDC commutation, algorithm design, and STM32 capabilities.</p><h2 id="reference-一些experimental-level-code" tabindex="-1">Reference: 一些experimental level code <a class="header-anchor" href="#reference-一些experimental-level-code" aria-label="Permalink to &quot;Reference: 一些experimental level code&quot;">​</a></h2><ul><li><a href="https://eltra-encoder.eu/news/quadrature-encoder" target="_blank" rel="noreferrer">Quadrature Encoder Tutorial</a></li><li><a href="https://github.com/zephyr-atomi/stm32f4-exp/blob/master/examples/qei.rs" target="_blank" rel="noreferrer">TLE5012 experiment</a></li><li><a href="https://github.com/zephyr-atomi/stm32f4-exp/blob/master/examples/motor-exp.rs" target="_blank" rel="noreferrer">Six-Step Commutation drive on odrive v3.6</a></li><li><a href="https://github.com/odriverobotics/ODriveHardware/blob/master/v3/v3.5docs/schematic_v3.5.pdf" target="_blank" rel="noreferrer">odrive circuit</a></li><li><a href="https://www.bilibili.com/video/BV1XvtNeaE54" target="_blank" rel="noreferrer">没有专业术语！新手小白也能看懂的FOC科普</a></li></ul>',55)]))}const f=i(h,[["render",p]]);export{b as __pageData,f as default};
